# -*- coding: utf-8 -*-
"""1-Basics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SrEiq46bEFp5zA59bcqE1K0myLvKg4tG

# 1. SEMANTICS
- Variables
- Expressions
- Types
- Input

# Input from keyboard

`input()` acquires simple text from keyboard and returns it as a `str`.
"""

z = input("insert a number: ")
print("your input: ", z)
if z>0:
    print("positive number: ", z)

"""To use the `>` operator on `z`, we must explicitly convert it to the needed type.

# Built-in types

Commonly used numerical and string types are

Type | Description |
:----|:-----------
 str | similar to C++ string 
 float | C double precision 
 complex | complex number with real parts x + yj
 int | integer 
 bool | boolean variable. special integer with just 1 bit

You must explicitly convert `input()` to desired type for use.
"""

x = int(input("Insert integer: ")) # What happens if input is float?
print("x = ", x)

"""Say we input 4.5.  The call is then `int('4.5')`.  To fix it we need to call `int(float('4.5'))`"""

x = int(float(input("Insert integer: "))) # Better
print("x = ", x)

x = int(input("Insert integer number: "))
y = float(input("Insert a rational number: "))

if x > y:
    print("x: {0} > y:{1}".format(x,y))
else: 
    print("y: {1} > x:{0}".format(x,y))

anint = int(input("Insert an integer: "))
print(anint)

"""An integer literal can be used as float: there is automatic conversion in this case."""

afloat = float(input("Insert a float: "))
print(afloat)

"""`j` is the imaginary unit."""

acomplex = complex(input("Insert a complex number: "))
print(acomplex)

"""## Bool type
Same as bool in C++. Used for logical operation and uses just one bit to store the info.
"""

c = 2.3 < 3
print(c, type(c), c.bit_length())

c = bool(0)
print(c, c.bit_length())

c = bool(-3)
print(c, c.bit_length())

d = True
print(d, int(d))

print(type(2.3), type(True), type("hello"))

"""## Integers in Python
Unlike in C/C++, you can have arbitrarily large integers in Python.
"""

j = 3**334 # 3^334
print(j)
print(type(j))
print((3**11567).bit_length())

"""Python3 is smart about integer division (Python2 had a different behaviour)"""

print(10/2) 
print(9/2) 
print(99/100) 
print(10.0/2.0) 
print(99.0/100.0)

"""### Integers in arbitrary bases

A neat feature of integers in Python is easy conversion to an arbitrary base
"""

a = int('101', base=2)
b = int(101)
print(a,b)

int('101', base=3)

int('101', base=5)

int('101', base=7)

int('101', base=8)

int('101', base=16)

int('1F', base=16)

x = int('FF01', base=16)
print(x)
print(int('1110001',base=2))
int('FF01', base=16) + int('1110001', base=2)

"""# Inline help and inspection
Use the inline help facility in the interactive Python session:
"""

help(int)

"""And since **everything is an object in Python**, you can list the attributes, data, and functions (which are all objects) within any object."""

dir(int)

help(int.bit_length)

help(bin)

bin(int('F0F', base=16))

"""There are actually built-in functions for easy base conversions."""

c = 23
print(bin(c), oct(c), hex(c))

0x1F + 3 +0b111

"""You can quickly exercise your ability in converting between hexadecimal and binary bases."""

print(hex(0b00011000))

print(hex(0b10011010))

"""# 2 FLOW CONTROL

- `if/elif/else` conditional statements
- `while` loops
- `for` loops
- `try/except/else/finally` statements
- `break`, `continue`, and `pass`

The main difference with respect to C++ is the lack of `}` and `;` for logical structure, which is instead achieved via the use of `:` and **indentation**

```c++
if(x<0) {
} else {
    cout << x << endl;
}
```

## Conditional statements with `if/elif/else`
"""

x = float(input("Insert a number: "))
if x < 0 :
    print("0 < x")
elif x < 1:
    print("0 < x < 1")
elif x < 10:
    print("1 < x < 10")
else:
    print("x > 10")

"""## `while` loop"""

w = -2
while w<0 or w>1:
    w = float(input("Insert x in [0,1]: "))

"""Easily create a user interface for input with control over user input"""

control = True
while control:
    w = float(input("insert x in [0,1]: "))
    if w>=0 and w<=1:
        control = False

"""## `for` loop
We have already seen that the use of a `for` loop that requires a sequence of objects to iterate over
"""

type(range(0,10,1))

help(range)

for i in range(1,11,2):
    print("i: %-3d\t i^2: %d" % (i, i**2))
    print("i: {0}\t i^2: {1}".format(i,i**2))

"""In this example you can also use the C-style `fprintf` formatting for displaying information.

## `try/except/else/finally`
"""

x = 3
y = 2
#y = 0

try:
    # Floor division
    result = x // y
except ZeroDivisionError:
    print("Sorry! You are dividing by zero")
else:
    print("Yeah! Your answer is:", result)
finally: 
    # This block is always executed  
    # regardless of exception generation. 
    print("This is always executed")

"""## `break`, `continue`, and `pass`

Spot prime numbers between 2 and 9
"""

for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # Loop fell through without finding a factor
        print(n, 'is a prime number')

"""Spot even and odd numbers between 2 and 9"""

for num in range(2, 10):
    if num % 2 == 0:
        print("Found an even number", num)
        continue
    print("Found an odd number", num)
    print("Moving on to the next number")

"""Spot odd numbers between 2 and 9

The keyword `pass` is needed for an empty scope. It does not skip anything. It only tells the interpreter that in this scope there is nothing to do. It is equivalent to `{}` in C++.
"""

for num in range(2, 10):
    if num % 2 == 0:
        pass
    else:
        print("Found an odd number", num)
    print("Moving on to the next number")

"""# 3. FUNCTIONS AND MODULES

As in other languages, a function is defined by its name and its arguments. But there is no return type nor do you need to specify the type of arguments. Any object can be the input to any function.

The generic structure of a function is
```python
def function(arg1, arg2, arg3=val):
    statements
    return value

next_statement
```

If a function does not return a value, a `None` value is returned automatically
"""

def decay(x, a=0.3, b=0.7):
    if x < a:
        print("Two body decay")
    elif x < b:
        print("Three body decay")
    else:
        print("Decay to 4 or more bodies")
    
decay(0.4)
decay(0.9, b=0.6)
# Also decay() has a return type
v = decay(0.003)
print(type(v))

# Import NumPy module
import numpy as np
x = np.random.random()
print("x = %.4f"%x)
decay(x)

print("\nSo what is import all about?")

"""## Python application and modules
An important difference with respect to C++ is the lack of an entry point.

A typical C/C++ application `app.cc` is
```c++
#include <stdio>
#include <math>

double uniform(double,double);

int main() {
  /*   code goes here */
  return 0;
}

double uniform(double a,double b) {
  /* implement uniform */
  return something
}
```
You compile and link the application using the math library as
```
g++ -o /tmp/app.exe -lm app.cc
```
and finally run the executable
```
/tmp/app.exe
```

Running the executable means that the operating system calls the `main()` function in `app.exe`.

**In python however there is no such thing!**

A program is any file containing python statements. Being an interpreted language, all statements are executed as they appear in the file.

The following examples showing the use of modules and namespaces are available in the classroom drive in the directory `examples/Python`.

Our first program is `example11.py`

```
# This is my first module

print("==== Running example11.py")

a = 2.3
b = 4.5
c = a/b

def line(x, m=1., q=0.):
  print("x: {2}, m: {0}, q: {1}".format(m,q,x))
  return m*x+q

# Print using ''
print('a = {0}, b = {1}, c = {2}'.format(a, b, c))


print(line(2., q=2.3))
print(line(0., q=-1.3))
print("==== End of example11.py")
```

__Reminder__: you can execute the program from the command line with 
```
python3 example11.py
```
In Jupyter you can run a local file (with path relative to the directory where you started the notebook session) by using the magic `%run` command.  E.g.

```
%run ./example11.py
```

### Our first module
Suppose you want to use the `line()` function in this example in other programs. Rather than copying the code by hand we want to use a library model, or what is called a __module__ in Python. 

Unlike C, there is  no special setup to create a module.

We write a second program `example12.py`
```python
import example11

print('===== Running 12example.py ===== ')

x = float(input("Insert x:"))
y = example11.line(x)
print(y)

# A much shorter way
print(example11.line(float(input("Insert x:"))))
```

and execute it from the command line

```shell
$ python3 example12.py
==== Running example11.py
a = 2.3, b = 4.5, c = 0.5111111111111111
x: 2.0, m: 1.0, q: 2.3
4.3
x: 0.0, m: 1.0, q: -1.3
-1.3
==== End of example11.py
===== Running example12.py ===== 
insert x:-123
x: -123.0, m: 1.0, q: 0.0
-123.0
insert x:23
x: 23.0, m: 1.0, q: 0.0
23.0
```

There are 2 important aspects to note
  1. The function `line()` belongs to the `example11` namespace. So you __must__ use `example11.line` to call it.
  2. By importing `example11`, in addition to the definition of function `line` you also execute the rest of the python program.
  This is expected because __python is an interpreted language__.
  
Let's address these 2 issues.

### Importing only some objects of a module
To address the first issue we can do the following in `example13.py`
```python
from example11 import line

print("++++ executing "+ __file__)

print(line(-3.4, q=0.5))
```
Now when we run the program:
```shell
$ python3 example13.py 
==== Running example11.py
a = 2.3, b = 4.5, c = 0.5111111111111111
x: 2.0, m: 1.0, q: 2.3
4.3
x: 0.0, m: 1.0, q: -1.3
-1.3
==== End of example11.py
++++ executing /Users/francesco/Documents/Work/Didattica/2021-22/2021-22 Computing Methods For Physics/Course Material 2021-22/examples/Python/example13.py
x: -3.4, m: 1.0, q: 0.5
-2.9
```

### Importing objects from a module and renaming them
A different approach is shown in `example14.py` where `line` is imported with a new name `p1`
```python
from example11 import line as p1

print("++++ executing "+ __file__)

print(p1(-3.4, q=0.5))
```
Produces

```shell
==== Running example11.py
a = 2.3, b = 4.5, c = 0.5111111111111111
x: 2.0, m: 1.0, q: 2.3
4.3
x: 0.0, m: 1.0, q: -1.3
-1.3
==== End of example11.py
++++ executing /Users/francesco/Documents/Work/Didattica/2021-22/2021-22 Computing Methods For Physics/Course Material 2021-22/examples/Python/example14.py
x: -3.4, m: 1.0, q: 0.5
-2.9
```

### What is imported? 
All objects defined in a module are available when a module is imported. 

This is shown in `example15.py`
```python 
import example11

print("++++ executing file: "+ __file__)

print("Calling example11.line(2.34, q=0.5): ", example11.line(2.34, q=0.5))

print("example11.a: %f" % example11.a)
```
When running in the terminal:

```shell
$ python3 example15.py
==== Running example11.py
a = 2.3, b = 4.5, c = 0.5111111111111111
x: 2.0, m: 1.0, q: 2.3
4.3
x: 0.0, m: 1.0, q: -1.3
-1.3
==== End of example11.py
++++ executing file: /Users/francesco/Documents/Work/Didattica/2021-22/2021-22 Computing Methods For Physics/Course Material 2021-22/examples/Python/example15.py
x: 2.34, m: 1.0, q: 0.5
Calling example11.line(2.34, q=0.5):  2.84
example11.a: 2.300000
```

### Importing only objects without executing statements
We now turn to our second problem, namely how to avoid running the statements in `example11.py` when importing it as a module.

This can be done with a more advanced feature of Python which we will understand better in future lectures. The solution is actually trivial. A modified version of `example11.py` is `mymodule.py`
```python
# This is my first module
a = 2.3
b = 4.5
c = a/b

def line(x, m=1., q=0.):
  print("=== In line === x: {2}, m: {0}, q: {1}".format(m,q,x))
  return m*x+q

print("__name__ : " +  __name__ + " in " + __file__)


if __name__ == "__main__":
  print("executing " +  __name__ + " in " + __file__)

  # Print using ''
  print('a = {0}, b = {1}, c = {2}'.format(a, b, c))
  print("calling line(): ", line(2., q=2.3))
  print("calling line()", line(0., q=-1.3))

  def p1(x, m=1., q=0.):
     print("x: {2}, m: {0}, q: {1}".format(m,q,x))
     return m*x+q
```
which has this behavior
```shell
$ python3 mymodule.py 
__name__ : __main__ in /Users/francesco/Documents/Work/Didattica/2021-22/2021-22 Computing Methods For Physics/Course Material 2021-22/examples/Python/mymodule.py
executing __main__ in /Users/francesco/Documents/Work/Didattica/2021-22/2021-22 Computing Methods For Physics/Course Material 2021-22/examples/Python/mymodule.py
a = 2.3, b = 4.5, c = 0.5111111111111111
=== in line === x: 2.0, m: 1.0, q: 2.3
calling line():  4.3
=== in line === x: 0.0, m: 1.0, q: -1.3
calling line() -1.3
```

To understand this better look at `example16.py`
```python
import mymodule

print("++++ executing namespace " + __name__ + " in file: " +  __file__)

# Local a variable
a = 'test string'

# Any object in mymodule can be used and there is no confusion with local a
print("mymodule.a: %f" % mymodule.a)
print("local a: ", a)

# Use line function from mymodule
print(mymodule.line(2.34, q=0.5))

# Function p1 is defined in mymodule but cannot be used because
# behind __name__ == "__main__" in mymodule
print(mymodule.p1(2.34, q=0.5))
```

At runtime we get the following error
```shell
$ python3 example16.py
__name__ : mymodule in /Users/francesco/Documents/Work/Didattica/2021-22/2021-22 Computing Methods For Physics/Course Material 2021-22/examples/Python/mymodule.py
++++ executing namespace __main__ in file: example16.py
mymodule.a: 2.300000
('local a: ', 'test string')
=== in line === x: 2.34, m: 1.0, q: 0.5
2.84
Traceback (most recent call last):
  File "example16.py", line 17, in <module>
    print(mymodule.p1(2.34, q=0.5))
AttributeError: 'module' object has no attribute 'p1'
```

When `mymodule` is imported it has its own namespace which is not `__main__`. At any time, only the Python program being executed has the `__main__` namespace as desired.

# 4. BUILT-IN DATA STRUCTURES: CONTAINERS AND SEQUENCES

- One of the great and popular features of Python is the presence of built-in containers for sequences of objects
  - These are provided by the STL in C++, but we have not discussed this (yet?)

- Since in Python everything is an object and all objects can be referenced in the same way, containers can include objects of different type
  - This is unlike anything seen in C++
  
- These built-in types and the reference-driven flexibility of Python has made it very popular for data analysis

- Basic built-in data structures in python are
  - tuple `(v1, v2, v3, ...)`
  - list `[v1, v2, v3, ...]`
  - dictionary `{key1:value1, key2:value2, key3:value3, ...)`
  - set `{v1, v2, v3, ...}`
  
- We will introduce more advanced types when discussing [NumPy](https://www.numpy.org) and [pandas](http://pandas.pydata.org) packages, e.g.
  - ndarrays
  - series
  - time series
  - DataFrame

## Tuples

A tuple is an **immutable** sequence of Python objects.
- Since Python does not have to build tuple structures to be modifiable, they are simpler and more efficient in terms of memory use and performance than lists (the next sequence container we will see).

To create a tuple simply separate its elements with a `,`.
"""

a = 'lec23', 'lec24', 'lec25'
print(a)

len(a)

"""Given the limitation of tuple (content and size are immutable) there are very few methods."""

dir(tuple)

"""One very useful one is `count()`"""

grades = (30, 22, 24, 23, 30, 18, 24, 27, 28, 28, 25, 24, 22, 30, 30, 18, 20)
grades.count(30)

"""A tuple can contain objects of different type"""

b = 'paul', 24, 1.75, 85.3
print(b)

print(a, b, 'hi')
print(type(b))

"""### Accessing tuple elements
Accessing the i-th element of a tuple is achieved with the `[]` operator
- Indexing starts with 0
"""

print(a[2])
print(b[3])
print(type(b[1]))
print(len(b))
print(b[4])

"""Note how there is protection against out-of-bound access to tuples.

### Empty or one-element tuple
"""

c = ()
print(type(c),c)

d = 'something',
print(type(d),d)

e = 'something'
print(type(e),e)

"""Note that the `,` is critical to distinguish a on-element tuple from a normal variable.

### Conversion to tuple
"""

print(range(10))

tup = range(10)
print("length: ", len(tup))
print("tup:", tup)
print(type(tup))

"""Note how `tup` is not a tuple but simply a refernce to function call `range(10)`.

If you want a tuple you have to explicitly convert the output of `range(10)` to be a tuple.
"""

tup = tuple(range(10))
print("length: ", len(tup))
print("tup: ", tup)
print(type(tup))

"""### Iterating over a tuple
- Is easy
"""

for i in tup:
    print(i)

"""### Converting strings to tuples"""

tup = tuple("Hello World!")
print("tup: ", tup)
print(len(tup))

for i in tup:
    print(i)

for i in tup:
    print(i, end=" >> ")
    
print("\n")

"""### Tuples can contain any object

Even a function is a valid object to be placed in a tuple
"""

def myprod(a, b=3.145, scale=1.0):
    return a*b*scale

tup = (1, 'name', myprod)
print("tup: ",tup)

for i in tup:
    print(type(i))

"""**Note how the use of default values is more flexible than in C**"""

bb = 3.2
print(tup[2](2, bb))
print(myprod(2, b=bb))

"""### A tuple can contain tuples as its elements"""

x = a, b, c, tup

for i in x:
    print("i: ", i)

print(x[2])
print(x[0])
print(x[3][2](3,5))  # calling function myprod contained in tup

"""### And once again: tuples are immutable

You can bind a variable to a new tuple but you cannot change an element of a tuple
"""

b[0] = 'one'

y = 'one', a, (2,3)
print(y)
print(b)

b = y
print(b)

ntuple  = 'lec23', 'lec27', 'lec25', 'lec25', 3.14, 3.56, 3.97
b = ntuple
print(b)
print(b.index('lec25'))
print(b.count('lec25'))
print(b.count(3.14))
print(type(b.count('lec25')))
print(b.index('test'))

"""### Tuples are comparable

The comparison operators work with tuples and other sequences. If the first item is equal, Python goes on to the next element, and so on, until it finds elements that differ.
"""

(0, 1, 2) < (5, 1, 2)

(0, 1, 2000000) < (0, 3, 4)

"""With strings it checks for alphabetical order"""

('Jones', 'Sally') > ('Adams', 'Sam')

('Jones', 'Sally') > ('Jones', 'Sally')

('Sally') > ('Sam')

('Sally') < ('Sam')

"""If it finds characters for numbers, it converts them to numbers for the comparison"""

('Jones10') > ('Jones11')

('Jones10') < ('Jones11')

"""## Lists
- Lists are also a collection of objects but unlike tuples they are **mutable**
  - variable length
  - each element can be modified
"""

alist = [2, 3, 4]
print(alist)
print(alist[2])
alist[2] = -3
print(alist)

"""Lists (and tuples) are protected against out of range index"""

print(len(alist))
alist[3]

# For negative indices, one basically has periodic boundary conditions
print(alist)
print(alist[-2])

"""But here too the list is protected against out of range index"""

print(alist[-4])

"""In summary: `-len(list)` $\leq$ index $<$ `len(list)`

A list can cantain any type of data. In this example the list is made of strings, float, int, function, lists, and tuples
"""

alist = ['one', 2, 3.24, myprod, (23, 24), ['lec1', 'lec2', [myprod, 3.14]]]
print(alist)
print(alist[5][2][0](6,7))

"""### Lists vs tuples
- A list is created using the `[]` operator or the explicit type `list`
- A tuple is created with the `()` operator or the explicit type `tuple`
- Lists and tuples are semantically similar
  - Many functions can take a tuple or a list
- Lists are used in data analysis to store data from iterators or generators
"""

values = range(-3, 10, 2)
print(values)
print(list(values))
print(tuple(values))

"""Note that as with tuples, you have to convert the output of `range` to be a list.

### List from tuple
You can create a list from a tuple by explicit conversion
"""

print(a)
blist = list(a)
print(blist)
blist[2] = 'lec28'
blist
a = tuple(blist)
print(a)

"""### List slicing

One of most popular featurs in data analysis with python is the possibility of accessing a subset of a collection by specifying the indices

```list[start:stop:step]```
"""

t = ['a', 'b', 'c', 'd', 'e', 'f'] 
print(t[1:3])
print(t[:4])
print(t[3:])
print(t[:])
print(t[::])
print(t[0:6:2])
print(t[:-2])
print(t[-2:])
print(t[-6:-2])

"""### Adding and removing list elements
- To add an element at the end of the list, use the `append()` method
- To insert a value at a specific location by providing the index, use the `insert()` method
- To remove an element from the list at a specific location use the `pop()` method
- To remove the **first occurrence** of an element (removal by value) from a list use the `remove()` method
"""

clist = ['one', 2, 3.14, 4, 'five']
clist.append(6)
print(clist)

clist.insert(2, 'two')
print(clist)

"""Note how the new element is inserted __before__ the indicated index."""

clist.pop(2)
print(clist)

"""The `insert` and `pop` methods have a return value. 

In particular with `pop` it is useful to see the value you have removed from the list
"""

x = clist.insert(2, 'test')
print (x)
x = clist.pop(2)
print(x)
print(clist)

"""Although not very efficient, you can `remove()` a given value from the list. It will only remove the first such occurrence. Python will linearly go through all elements until it finds the first occurrence."""

print(4 in clist)
print(clist)
clist.append(4)
print(clist)

if 4 in clist:
    clist.remove(4)
print(clist)

if 4 in clist:
    clist.remove(4)
print(clist)

"""### Combining lists
Use `+` to combine or extend exisiting or new lists
"""

print(blist)
print(clist)
all = blist + ['id', 'name', 'major']
print(all)

"""Note that this is very different from the following"""

all = [blist, 'id', 'name', 'major']
print(all)

print(all.index('id'))
print(all[-1])
print(all[-3])

"""The most efficient way to extend a list is with `extend`. It can take one or more elements to be added."""

all.extend([2, 3, 4, 'test', 'python'])
print(all)
all.append(4.56)
print(all)
# extend works with both round and square brackets
all.extend((2, 3))
print(all)
# Append takes a single parameter, so (2,3) is interpreted as a tuple
all.append((2, 3))
print(all)
print(all[all.index((2, 3))])
print(all[all.index((2, 3))][1])
print(all[-1][1])

"""### More on the difference between `append()` and `extend()`"""

list_1 = [1, 2, 3]
list_2 = [1, 2, 3]

list_3 = [10, 11]

list_1.append(list_3)
list_2.extend(list_3)

print("append to a list: ", list_1)
print("extend a list: ", list_2)

"""### Sorting a list
Lists of elements that can be compared to each other can be sorted
"""

print(all)
all.sort()

months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
print(months)

months.sort()
print(months)

months.sort(key=len)
print(months)

help(list.sort)

months.sort(key=len,reverse=True)
print(months)

months.sort(reverse=True)
print(months)

print(months)
months.sort()
print(months)

"""### `sort()` vs `sorted()`
In these examples, `sort()` is **applied** to the object and **modifies** it.  We might prefer keeping the data intact and have a new sorted copy, instead.
"""

months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
print(months)

sorted_months_byname = sorted(months)
print(sorted_months_byname)

sorted_months_bylen = sorted(months, key=len)
print(sorted_months_bylen)

print(months)

help(sorted)

"""### Lists and strings"""

chars = list("in a far away galaxy")
print(chars)
chars.count(' ')

"""The `split()` method breaks a string into parts and produces a list of strings."""

sentence = "I quite like Python"
words = sentence.split()
print(words)

speech = "I quite like Python. I liked C++ as well. Anyways, let's carry on."
sentences = speech.split('.')
print(sentences)

for sentence in sentences:
    words = sentence.split()
    print(words)

"""### The `enumerate()` function
Keeps track of index while iterating on a collection, e.g., a list.

`enumerate` can be exploited in `for` loops.
"""

print(months)

for i,m in enumerate(months):
    print("month %-2d: %s" % (i+1, m))

data = 'name', 'surname', 'id'

for i,d in enumerate(data):
    print(i, "\t", d)

"""### References and lists
All collection objects are handled as a reference. This is shown explicitly in this example.
"""

newlist = months
print(newlist)

newlist.append('NewMonth')
print(months)

"""So `newlist` __is not a new copy__. `newlist` and `months` are simply two references to the same list object!

To have a new copy you have to use the explcit conversion.
"""

newlist = list(months)
newlist.append('CrazyMonth')
print(months)
print(newlist)

"""## Dictionaries
- Another collection of objects
  - **Mutable** (variable length and modifiable)
  - **Unordered** (unlike tuples and lists)
  

Very similar to the associative container `map<T,K>` discussed in C++. They are also known as __hash tables__ in other languages, e.g. `perl`.  To create a `dict` object:

```python
my_dict = { key1 : value1, key2: value2, ... }
```

or

```python
my_dict = dict()
my_dict['key1'] = value1
my_dict['key2'] = value2
...
```

or
```python
my_dict = dict([('key1', value1), ('key2', value2), ...])
```

### Dictionary creation

#### Empty dictionary
"""

my_dict = dict()
print(my_dict)

my_dict = {}
print(my_dict)

"""#### 2 separate lists become a 1 dictionary"""

# Two separate lists...
months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
day_months = [31, 28, 31, 30, 31 , 30, 31, 31, 30, 31, 30 , 31]
print(months)
print(day_months)

print("month: ", months[0], " has ", day_months[0], " days")

# ...a dictionary!
days_per_month = {}

for i, m in enumerate(months):
    days_per_month[m] = day_months[i]
    
print(days_per_month)
print(days_per_month['january'])
print(days_per_month['february'])

"""The `items()` method in dictionaries returns a list of `(key, value)` tuples"""

print(days_per_month.items())

"""#### You can also create a dictionary by hand"""

dict1 = {'a' : 1,
         'b' : (1,2,3),
         'c' : ['one','two'],
         'd' : 'example',
         56 : 'name'}
print(dict1)

students = {'rio': {'name':'john', 'age':23, 'id':123456},
            'nairobi': {'name':'susan', 'id':123123, 'age':21}, 
            'tokyo': {'name':'maria', 'id':123651, 'age':24}, }
print(students)

"""#### Adding a new value for a key"""

students['oslo'] = {'name':'', 'age':30, 'id':111111} 
print(students)

"""If the key is already in use, its value will be updated (similar to modifying elements of a list)"""

students['oslo'] = {'name':'sergey', 'age':22, 'id':111112} 
print(students)

"""### `KeyError`, `in`, and `get`

`KeyError` is the error you hit when referencing a `key` which is not in the dictionary
"""

students['osaka']

"""#### Use the `in` operator to checking whether a `key` is in use"""

while True:
    name = input("Name (press return to end): ")  
    if(name==''): break
    if name not in students:
        print("{0} not in the list. sorry.".format(name))
    else: 
        print("name: {0}\t age: {1}\t id: {2}".format(students[name]['name'], students[name]['age'], students[name]['id']))

"""#### `get`

- Dedicated getter method for dictionaries
- Has a fall-back feature to avoid `KeyError`
- Syntax:

```python
value = some_dict.get(key, value_if_key_not_found)
```
"""

while True:
    name = input("Name (press return to end): ")  
    if(name==''): break
    val = students.get(name, "not found")
    print(val)

"""### Keys are unique
- There can be only one `value` for a given `key` in a dictionary made of `key:value`
- If you need more values for a `key`, then what you want is a dictionary of `key:[value]` 
"""

particles = {'boson':['Z', 'gluon', 'W', 'photon'],
             'meson':['pion', 'kaon'],
             'quark':['u','d','s'],
             'lepton':['electron', 'muon']}
particles

particles['lepton'].append('tau')
particles

"""### Iterating over dict 
By default the iterator gives you the keys.  You can also *explicitly* loop over keys.
"""

for p in particles:
    print(p)

print(particles.keys())
for k in particles.keys():
    print(k)

for k in particles:
    print(particles[k])

"""#### There is more: two iteration variables!

You can loop through the `key:value` pairs in a dictionary using **two** iteration variables.
At each iteration, the first variable is the `key` and the second variable is its corresponding `value`.
"""

for aaa,bbb in particles.items():
    print(aaa, 'list:', bbb)

"""### Accessing values without keys
If you do not care about the keys, but need all the values python provides with `values` function.

This operation is also called __flattening__.
"""

print(particles.values())

all_vals_ext = []
all_vals_app = []

for v in particles.values():
    print("Looping over keys in dict")
    print(v)
    all_vals_ext.extend(v)
    all_vals_app.append(v)

print("All_vals (flattened)")
print(all_vals_ext)

print("All_vals (not flattened)")
print(all_vals_app)

dic2 = {123: (1,2,3), 'one': [1.2, 2.3] , (1,2): 'tuple'}
print(dic2)
for i in dic2:
    print(type(i), type(dic2[i]))

"""Same behavior can be obtained with a double loop."""

flat=[]
for v in particles.values():
    for i in v:
        flat.append(i)
print(flat)

"""### Valid key types
- Keys must be hashable, i.e., a unique identifier can be created based on a given key.
- Hashable types:
    - immutable scalar type such as int, float, string
    - tuples
- You can check if a variable is hashable or not with `hash()`
"""

hash('boson')

hash((2,3,2.4))

hash(3.1234324)

c = 2.9
dict3 = {c:'Value of c', 5.9:'Value of something'}
print(dict3)

c = 5.4
dict3[c] = 'New'
print(dict3)

c = 5.6
dict3[-3.4] = 'New val'
print(dict3)

dict4 = {[1,2] : 'value'}

hash([1,2])

"""### Sorting a dictionary by `key`

We can take advantage of the ability to sort a list of tuples to get a sorted version of a dictionary.

First we sort the dictionary by the `key` using the `items()` method and `sorted()` function.
"""

d = {'a':1, 'c':3, 'b':2}
d.items()

sorted(d.items())

print(d) # NB: dictionary is unchanged

"""### Sorting a dictionary by `value`

Requires constructing a list of tuples of the form `(value, key)` to sort by `value`.
"""

tmp = list()
for k, v in d.items():
    tmp.append((v, k))
print(tmp)

tmp = sorted(tmp, reverse=True)
print(tmp)

"""## Sets

A **set** is

- an unordered collection of __unique__ elements
- the natural example is the collection of the keys of a dictionary

A set is created with `{}` or with the `set` function
```python
{v1, v2, v3, ...}
```
```python
my_set = set(v1, v2, v3, ...)
```

Consider our `days` dictionary that stores the days for each month
"""

#day_len = days_per_month.values()
day_len = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
day_len

"""We can create a set from this list"""

days_set = set(day_len)
print(days_set)

new_set = {1, 2, 3, 4, 1, 34, 3, 2, 34}
print(new_set)

my_tuple = (1, 2, 3, 2, 2, 3, 1)
print(set(my_tuple))

"""### Note that `{}` on its own creates a dictionary, not a set"""

tmp = {}
type(tmp)

tmp = set()
type(tmp)

"""### Examples of common operations"""

new_set2 = {1, 3, 33}

print(new_set)
print(new_set2)

print(new_set.intersection(new_set2))
print(new_set2.intersection(new_set))

new_set.union(new_set2)

new_set.difference(new_set2)

new_set.symmetric_difference(new_set2)

new_set & new_set2

new_set | new_set2

print(new_set)
new_set.add(5)
print(new_set)
new_set.remove(5)
print(new_set)

"""## Comprehensions for lists, sets, dictionaries
- One of Pythons most loved features
- Allows concise operation on collections without too many loops
- Output of the operation is a new collection (set, list, dict)

The basic expression for lists is

```python
[ expression(element) for element in collection if some_condition ]
```

Similar ones hold for other collections.  Basically, rather than writing, e.g.,
```python
a = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
even = {0, 2, 4, 6, 8}
odd = {1, 3, 5, 7, 9}
```
by hand we can use a comprehension with an algorithm.

### Example 1: odd and even numbers
"""

# For loop
aa = set()
for j in range(10):
    aa.add(j)
print(aa)

# Comprehension
a = {i for i in range(10)}
print(a)

even = {i for i in range(0,10,2)}
print(even)

odd = {i for i in range(1,10,2)}
print(odd)

"""### Example 2: grades (using sets and lists for data analysis)

#### Digression: generating random numbers
Suppose we want to analyse the results of an exam. 

First we need to generate N grades between 10 and 30.

As we saw previously, the [random](https://docs.python.org/3/library/random.html) module provided many useful functions for generation of random numbers or collections of numbers
"""

import random as r

n_students = 50

grades = []

for i in range(n_students):
    grades.append(r.randrange(10,31))
print(grades)

"""The same (modulo the randomness of the numbers!) but using **comprehension**"""

grades = [r.randrange(10,31) for i in range(n_students)]
print(grades)

"""Using `set` we find the unique values of `grades`"""

vals = set(grades)
print(vals)
print(grades.count(18))
print(grades.count(23))

data = {}
for v in vals:
    data[v] = grades.count(v)
    print("grade: {0}  frequency: {1}".format(v,data[v]))

"""The most basic question is how many people failed the exam.

You could do simple counting:
"""

nfail = 0
for v in grades:
    if v < 18:
        nfail += 1
print("# grades <18:  %2d"%(nfail))

"""In general, however, having a list of information rather than just a count is more flexible for future analyses."""

failed = []
for v in grades:
    if v < 18:
        failed.append(v)
print("# grades <18:  {0}".format(len(failed)))

"""Note that the following sequence of operations was performed
  - creation of a new empty list
  - iteration over existing objects
  - check of some_condition on each object
  - if outcome of check is positive object added to new list

Once again, this can be written concisely with __comprehension__.
"""

new_failed  = [v for v in grades if v<18]
good_grades = [v for v in grades if v>=18]
print(len(new_failed), len(good_grades))

"""You can also also apply any function to each item."""

def isodd(x):
    if x%2 != 0:
        return True
odds  = [v for v in grades if isodd(v)]
evens  = [v for v in grades if not isodd(v)]
print(len(odds))
print(len(evens))

import math
sqrts = [math.sqrt(v) for v in grades]
print(sqrts[:10])

"""### Example 3: comprehension with dictionaries
We now use a comprehension to invert our dict of months and days
"""

# Two separate lists...
months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december']
day_months = [31, 28, 31, 30, 31 , 30, 31, 31, 30, 31, 30 , 31]
# ...a dictionary!
days_per_month = {}

for i, m in enumerate(months):
    days_per_month[m] = day_months[i]

days_per_month.values()

set(days_per_month.values())

inv_map = {i: [] for i in set(days_per_month.values())}
print(inv_map)

for i in days_per_month:
    inv_map[days_per_month[i]].append(i)
print(inv_map)

"""# 5. FILES

As in C, the first step is to open a file object on disk before extracting/writing information from/into it
  
Main syntax
```Python
handle = open(filename, mode)
```

- `filename` is the path to the file and is a string
- `mode`: optional; possible modes are:


| Character | Meaning |
| :-: | :-- |
| `r` | open for reading (default) |
| `w` | open for writing, truncating the file first |
| `x` | create a new file and open it for writing |
| `a` | open for writing, appending to the end of the file if it exists |
| `b` | binary mode |
| `t` | text mode (default) |
| `+` | open a disk file for updating (reading and writing) |

Opening a file can fail
  - location does not exist
  - no write privilege for the location

It is important to close the file to make sure that (when writing) all data are flushed from memory to disk and the file handle closed properly.
"""

# If you are running on google colab, make sure you
# upload examples/Python/words.txt to the directory
# content/ (the default search space for a jupyter
# notebook on colab)

fh = open('words.txt', 'r')

print(fh)
print(type(fh))
fh.close()

"""Bonus track: see what files are available in the current working directory.

Not that you get to see hidden files (e.g., `.ipynb_checkpoints`).
"""

import os

l0 = os.listdir()

print(l0)

"""# Reading text files

### Line-by-line

A file handle opened in read mode can be treated as a **sequence of strings**.

Each line in the file is a string in the sequence.

NB: if you read numbers and want to process them, you will have to convert them from string to a number type.
"""

fh = open('words.txt', 'r')
lines = []

for line in fh:
    print(line)
    lines.append(line)

print(lines)

fh.close()

"""#### Note the `\n` newline character
- It causes the blanks
- Use `rstrip` to get rid of them
"""

fh = open('words.txt', 'r')
lines = []

for line in fh:
    line = line.rstrip()
    print(line)

fh.close()

"""### All at once

We can read the whole file (newlines and all) into a **single string** with `read()`
"""

fh = open('words.txt', 'r')
content = fh.read()
print(len(content))
print(content[:20])

fh.close()

"""### So how do I get words?  `split()`!"""

fh = open('words.txt', 'r')
lines = []
words = []

for line in fh:
    line = line.rstrip()
    words.extend(line.split())

print(words)

fh.close()

"""## Searching through a file
* `startswith()`
* `in`
* `endswith()`
"""

fh = open('words.txt', 'r')
for line in fh:
    line = line.rstrip()
    if line.startswith('Duis'):
        print(line)

fh.close()

fh = open('words.txt', 'r')
for line in fh:
    line = line.rstrip()
    if not 'esse' in line:
        print(line)

fh.close()

fh = open('words.txt', 'r')
for line in fh:
    line = line.rstrip()
    if line.endswith('laborum.'):
        print(line)

fh.close()

"""## Writing to a text file

By default `write()` does  not have a carriage return so you need to add `\n` to start a new line.
"""

fname = 'output.txt'
fh = open(fname, 'w')

fh.write('first file in python\n')
fh.write('a second line\n')
    
fh.close()

"""Check that the file was created"""

l0

lnew = set(os.listdir())

new_items = lnew.difference(l0)
print(new_items)

"""Check the file content Python-ically"""

fh = open(fname, 'r')
for line in fh:
    line = line.rstrip()
    print(line)

fh.close()

"""Check it again using the magic Jupyter `!` powers"""

!cat output.txt

"""## Getting rid of `close()`

To make it less C-like and feel more like Python we can get rid of `close()` by using the `with` statement.

`with` makes sure that ofile is an open file handle in the `with` scope. Once it ends you can no more use the handle, because `close()` has been called automatically.
"""

fname = 'output2.txt'

with open(fname, 'w') as ofile:
  ofile.write('A new file in python\n')
  ofile.write('1.2 3.2 4.5\n')

!cat output2.txt

"""**Deleting the two output files to avoid having a proliferation of small test files.**"""

!rm output.txt
!rm output2.txt

"""## Storing lists and multiple values

You can use the C-style output to format and store elements of a list
"""

import random  # Let's generate some random numbers

nevents = 3

fname = 'output.txt'

with open(fname,'w') as f:
    for i in range(nevents):
        measurements = [random.random() for j in range(5)]
        for val in measurements:
            f.write("%.5f\t"%val)
        f.write('\n')

!cat output.txt
!rm output.txt

"""A more Pythonic approach is to use the `writelines()` function and comprehensions"""

import random

nevents = 10

fname = 'output.txt'
with open(fname,'w') as f:
    for i in range(nevents):
        f.writelines("%.3f\t"%val for val in [random.random() for j in range(5)])
        f.write('\n')

!cat output.txt

"""Let's read the file assuming we have to process its data
- we need to remove the `\t`'s
- we need to ensure we have floats
"""

fname = 'output.txt'
lines = [l.strip() for l in open(fname)]
print(lines)

fname = 'output.txt'
lines = [l.strip() for l in open(fname)]
raw_data = [l.split('\t') for l in lines]
print(raw_data)

data = [[float(n) for n in l] for l in raw_data]
print(data)

"""Even more concisely"""

fname = 'output.txt'
data = [[float(n) for n in l.strip().split('\t')] for l in open(fname)]
print(data)

!rm output.txt # Cleaning up

"""## Storing Lists, Dicts, and Tuples

As seen with the examples above, **with textfile there is no automatic writing of objects**. So for a dictionary you need to take care of formatting the output file. 
"""

import random

datum = {'val':-1.1, 'err':0.2}

fname = 'output.txt'

with open(fname,'w') as f:
    f.writelines("%s\t"%v for v in datum.keys())
    f.write('\n')
    for i in range(10):
        datum['val'] = random.uniform(-3.,3.)
        datum['err'] = random.normalvariate(0., 0.2)
        f.writelines("%.3f\t"%val for val in datum.values() )
        f.write('\n')

!cat output.txt
!rm output.txt # Cleaning up

"""## Data storage with `pickle` 

Python provides a built-in [pickle]() library for easy storage of Python object hierchies in binary format: this is known as **pickling**.

Notice the `b` in the handle: it stands for binary.
"""

import random
import pickle
import os

data = {'val':[], 'err':[]}
for i in range(10):
    data['val'].append(random.uniform(-3.,3.))
    data['err'].append(random.normalvariate(0., 0.2))

fname = 'pickle1.data'
with open(fname,'wb') as f:
    pickle.dump(data,f)

os.listdir()

"""**Unpickling** is the opposite process, namely reading the binary file and rebuilding the object hierarchy.

Notice the `b` in the handle: it stands for binary.
"""

fname = 'pickle1.data'
with open(fname,'rb') as f:
    in_data = pickle.load(f)
   
print(data == in_data)
!rm pickle1.data

"""## Data storage with JSON 

A commonly used format for data storage that is cross platform and cross language is [JSON (JavaScript Object Notation)](https://www.json.org).

The JSON library in Python allows you to convert Python objects (including your custom classes) into JSON for storage.

Converting or enconding an object into JSON is commonly called **serialization**. Converting from JSON to Python objects is referred to as **deserialization**. See [this page](https://realpython.com/python-json/) for further details.

There are two functions commonly used:
- `dump()`: convert an object into JSON and possibly write to file
- `dumps()` note the extra **s**: convert to JSON string but cannot interact with file

The two functions are identical except for the file interaction.

The following is an example of a dictionary and a list being stored into JSON files.
"""

import json
import os

dict_data = {'val':-1.1, 'err':0.2}

x = json.dumps(dict_data)
print(x, dict_data)
print(type(x), type(dict_data))

list_data = [z for z in range(10)]
y = json.dumps(list_data)
print(y, list_data)
print(type(y), type(list_data))

with open('data.json','w') as of:
    json.dump([dict_data, list_data], of)

"""**Deserialize** the data from file with `load()`"""

with open('data.json') as infile:
    indata = json.load(infile)
print(indata)

# Showing consistency between what was written to and what was read from file
print(dict_data == indata[0])
print(type(indata[0]))
print(list_data == indata[1])
print(type(indata[1]))

!rm data.json # Cleaning up

"""# READY FOR `examples/Python/2-FirstApplications.ipynb`!"""